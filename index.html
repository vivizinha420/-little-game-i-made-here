<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover"/>
<title>Arcade Touch — Labirinto (Joystick Corrigido)</title>
<style>
  :root{
    --bg1:#05001a; --bg2:#0b0033; --wall:#00f0ff; --pill:#ffd166; --player:#ffe600; --ui-bg: rgba(255,255,255,0.06);
  }
  html,body{height:100%;margin:0;font-family:Inter, Arial; background:linear-gradient(160deg,var(--bg1),var(--bg2)); color:#fff; -webkit-tap-highlight-color: transparent;}
  .container{display:flex;flex-direction:column;align-items:center;padding:12px;box-sizing:border-box;height:100vh;}
  header{width:100%;max-width:900px;display:flex;justify-content:space-between;align-items:center;}
  h1{font-size:16px;margin:0;color:#0ff;text-shadow:0 0 8px #0ff;}
  .panel{background:var(--ui-bg);padding:6px 10px;border-radius:8px;font-size:13px;color:#bff;}
  main{margin-top:12px;display:flex;justify-content:center;width:100%;}
  canvas{background:#000;border-radius:10px;box-shadow:0 0 30px rgba(0,255,255,0.06) inset;}
  /* joystick */
  .controls{position:fixed;left:18px;bottom:18px;width:120px;height:120px;border-radius:50%;background:rgba(255,255,255,0.04);display:flex;align-items:center;justify-content:center;z-index:9999;touch-action:none;}
  .stick{width:56px;height:56px;border-radius:50%;background:rgba(0,255,255,0.16);display:flex;align-items:center;justify-content:center;transition:transform 0.02s linear;touch-action:none;user-select:none;}
  /* right ui */
  .right-ui{position:fixed;right:18px;bottom:18px;display:flex;flex-direction:column;gap:10px;z-index:9999}
  .btn{background:rgba(0,255,255,0.08);padding:8px 12px;border-radius:8px;color:#0ff;cursor:pointer;user-select:none}
  .hint{font-size:12px;opacity:0.75;margin-top:8px}
  @media(min-width:900px){ canvas{width:700px;height:700px} }
</style>
</head>
<body>
  <div class="container">
    <header>
      <h1>ARCADE LABIRINTO</h1>
      <div style="display:flex;gap:8px;">
        <div class="panel">Pontos: <span id="score">0</span></div>
        <div class="panel">Tempo: <span id="timer">00:00</span></div>
        <div class="panel">Vidas: <span id="lives">3</span></div>
      </div>
    </header>

    <main>
      <canvas id="game" width="560" height="560"></canvas>
    </main>
    <div class="hint">Use o joystick (arraste) ou setas/WASD no teclado.</div>
  </div>

  <!-- joystick -->
  <div class="controls" id="joystick" role="application" aria-label="Joystick - controle">
    <div class="stick" id="stick"></div>
  </div>

  <div class="right-ui">
    <div class="btn" id="startBtn">Iniciar</div>
    <div class="btn" id="pauseBtn">Pausar</div>
  </div>

<script>
/* ---------- Config & canvas ---------- */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score'), timerEl = document.getElementById('timer'), livesEl = document.getElementById('lives');
const startBtn = document.getElementById('startBtn'), pauseBtn = document.getElementById('pauseBtn');

const tileCount = 20;
const tileSize = canvas.width / tileCount;

/* ---------- Map generation (labirinto) ---------- */
function genMap(){
  const m = Array.from({length:tileCount}, ()=>Array(tileCount).fill(0));
  for(let i=0;i<tileCount;i++){ m[0][i]=1; m[tileCount-1][i]=1; m[i][0]=1; m[i][tileCount-1]=1; }
  for(let r=2;r<tileCount-2;r+=2){
    for(let c=2;c<tileCount-2;c+=2){
      if(Math.random() > 0.20){
        m[r][c]=1;
        if(Math.random()>0.5) m[r][c+1]=1;
        if(Math.random()>0.5) m[r+1][c]=1;
      }
    }
  }
  // clear start zone
  m[1][1]=0; m[1][2]=0; m[2][1]=0;
  // scatter walls
  for(let i=0;i<Math.floor(tileCount*tileCount*0.06);i++){
    const rx = 1 + Math.floor(Math.random()*(tileCount-2));
    const ry = 1 + Math.floor(Math.random()*(tileCount-2));
    m[ry][rx] = 1;
  }
  return m;
}
let map = genMap();

/* ---------- Player & ghosts ---------- */
const player = { x:1.5, y:1.5, dirX:0, dirY:0, speed:4, size: tileSize*0.4, mouthAnim:0 };
class Ghost{ constructor(x,y,color){ this.x=x; this.y=y; this.color=color; this.dirX=0; this.dirY=0; this.speed=2.2; } }
const ghosts = [
  new Ghost(tileCount-2.5,1.5,'#ff3366'),
  new Ghost(1.5,tileCount-2.5,'#44ff99'),
  new Ghost(tileCount-2.5,tileCount-2.5,'#66bbff')
];

let score = 0, lives = 3, running=false, paused=false, startTime=0, elapsed=0;

/* ---------- Utility: collision & movement ---------- */
function isWallAt(x,y){
  const tx = Math.floor(x), ty = Math.floor(y);
  if(ty < 0 || ty >= tileCount || tx < 0 || tx >= tileCount) return true;
  return map[ty][tx] === 1;
}
function moveEntity(e, distance){
  if(e.dirX === 0 && e.dirY === 0) return;
  const step = 0.02;
  const steps = Math.max(1, Math.ceil(distance/step));
  const sx = (e.dirX * distance) / steps;
  const sy = (e.dirY * distance) / steps;
  for(let i=0;i<steps;i++){
    if(!isWallAt(e.x + sx, e.y)) e.x += sx; else { if(e===player) player.dirX = 0; else e.dirX = 0; }
    if(!isWallAt(e.x, e.y + sy)) e.y += sy; else { if(e===player) player.dirY = 0; else e.dirY = 0; }
  }
}

/* ---------- BFS para perseguir o jogador (retorna primeiro passo) ---------- */
function nextDirToPlayer(g){
  const start = [Math.floor(g.x), Math.floor(g.y)];
  const goal = [Math.floor(player.x), Math.floor(player.y)];
  if(start[0] === goal[0] && start[1] === goal[1]) return [0,0];
  const q = [start];
  const visited = new Set([start.join(',')]);
  const parent = {};
  while(q.length){
    const [cx,cy] = q.shift();
    for(const [dx,dy] of [[1,0],[-1,0],[0,1],[0,-1]]){
      const nx = cx + dx, ny = cy + dy;
      const key = nx+','+ny;
      if(nx < 0 || ny < 0 || nx >= tileCount || ny >= tileCount) continue;
      if(map[ny][nx] === 1) continue;
      if(visited.has(key)) continue;
      visited.add(key);
      parent[key] = cx+','+cy;
      if(nx === goal[0] && ny === goal[1]){
        // backtrack to immediate neighbor of start
        let k = key;
        while(parent[k] && parent[k] !== start.join(',')){
          k = parent[k];
        }
        const [fx,fy] = k.split(',').map(Number);
        return [fx - start[0], fy - start[1]];
      }
      q.push([nx,ny]);
    }
  }
  return [0,0];
}

/* ---------- Update e lógica do jogo ---------- */
function hasPills(){
  for(let y=0;y<tileCount;y++) for(let x=0;x<tileCount;x++) if(map[y][x] === 0) return true;
  return false;
}
function handleDeath(){
  lives--;
  livesEl.textContent = lives;
  if(lives <= 0){
    running = false;
    paused = true;
    alert('Game Over! Pontos: ' + score);
    resetGame();
    return;
  }
  player.x = 1.5; player.y = 1.5; player.dirX = player.dirY = 0;
  ghosts[0].x = tileCount-2.5; ghosts[0].y = 1.5;
  ghosts[1].x = 1.5; ghosts[1].y = tileCount-2.5;
  ghosts[2].x = tileCount-2.5; ghosts[2].y = tileCount-2.5;
}

function update(dt){
  elapsed = (performance.now() - startTime) / 1000;
  timerEl.textContent = formatTime(Math.floor(elapsed));
  // player
  moveEntity(player, player.speed * dt);
  player.mouthAnim += dt * 8;

  // ghosts: decidir direção via BFS em encruzilhadas ou ocasionalmente
  ghosts.forEach(g => {
    if(g.dirX === 0 && g.dirY === 0 || Math.random() < 0.04 || isWallAt(g.x + g.dirX*0.6, g.y + g.dirY*0.6)){
      const [dx,dy] = nextDirToPlayer(g);
      g.dirX = dx; g.dirY = dy;
    }
    moveEntity(g, g.speed * dt);
  });

  // colisões
  ghosts.forEach(g=>{
    if(Math.hypot(g.x - player.x, g.y - player.y) < 0.6){
      handleDeath();
    }
  });

  // colher pílulas
  const px = Math.floor(player.x);
  const py = Math.floor(player.y);
  if(map[py] && map[py][px] === 0){
    map[py][px] = 2;
    score += 10;
    scoreEl.textContent = score;
    if(!hasPills()){
      running = false;
      paused = true;
      alert('Você venceu! Pontos: ' + score);
      resetGame();
    }
  }
}

/* ---------- Render ---------- */
function draw(){
  // background
  ctx.fillStyle = '#000';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // tiles
  for(let y=0;y<tileCount;y++){
    for(let x=0;x<tileCount;x++){
      const t = map[y][x];
      const px = x * tileSize, py = y * tileSize;
      if(t === 1){
        ctx.save();
        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--wall').trim() || '#00f0ff';
        ctx.shadowColor = ctx.fillStyle;
        ctx.shadowBlur = 10;
        roundRect(ctx, px+2, py+2, tileSize-4, tileSize-4, 6);
        ctx.fill();
        ctx.restore();
      } else if(t === 0){
        ctx.beginPath();
        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--pill').trim() || '#ffd166';
        ctx.arc(px + tileSize/2, py + tileSize/2, Math.max(1, tileSize*0.08), 0, Math.PI*2);
        ctx.fill();
      }
    }
  }

  // player (com boca)
  const cx = player.x * tileSize;
  const cy = player.y * tileSize;
  const r = tileSize * 0.38;
  const mouth = Math.abs(Math.sin(player.mouthAnim)) * 0.6;
  ctx.beginPath();
  ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--player').trim() || '#ffe600';
  ctx.moveTo(cx, cy);
  ctx.arc(cx, cy, r, mouth * Math.PI, (2 - mouth) * Math.PI);
  ctx.fill();

  // ghosts
  ghosts.forEach(g => {
    const gx = g.x * tileSize;
    const gy = g.y * tileSize;
    drawGhost(gx, gy, g);
  });
}

function drawGhost(x,y,g){
  const r = tileSize*0.35;
  ctx.save();
  ctx.fillStyle = g.color;
  ctx.beginPath();
  ctx.arc(x, y - r*0.15, r, Math.PI, 0);
  ctx.lineTo(x + r, y + r*0.55);
  // scallops
  const scallop = r/4;
  for(let i=-1;i<=1;i++){
    ctx.quadraticCurveTo(x + i*scallop, y + r*0.85, x + (i+1)*scallop, y + r*0.55);
  }
  ctx.fill();
  // olhos
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.ellipse(x - r*0.28, y - r*0.08, r*0.22, r*0.26, 0, 0, Math.PI*2);
  ctx.ellipse(x + r*0.08, y - r*0.08, r*0.22, r*0.26, 0, 0, Math.PI*2);
  ctx.fill();
  ctx.beginPath();
  ctx.fillStyle = '#000';
  // olhos olham na direção do movimento
  const dx = g.dirX * 0.08 * tileSize;
  const dy = g.dirY * 0.08 * tileSize;
  ctx.arc(x - r*0.28 + dx, y - r*0.08 + dy, r*0.09, 0, Math.PI*2);
  ctx.arc(x + r*0.08 + dx, y - r*0.08 + dy, r*0.09, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();
}

function roundRect(ctx,x,y,w,h,r){
  if(w < 2*r) r = w/2;
  if(h < 2*r) r = h/2;
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.closePath();
}

/* ---------- Game loop ---------- */
let lastTime = performance.now();
function loop(ts){
  const dt = Math.min(0.06, (ts - lastTime) / 1000);
  lastTime = ts;
  if(running && !paused) update(dt);
  draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* ---------- Controls: teclado ---------- */
window.addEventListener('keydown', (e)=>{
  if(e.key === 'ArrowUp' || e.key === 'w'){ player.dirX = 0; player.dirY = -1; }
  if(e.key === 'ArrowDown' || e.key === 's'){ player.dirX = 0; player.dirY = 1; }
  if(e.key === 'ArrowLeft' || e.key === 'a'){ player.dirX = -1; player.dirY = 0; }
  if(e.key === 'ArrowRight' || e.key === 'd'){ player.dirX = 1; player.dirY = 0; }
  if(e.key === 'p') togglePause();
});
window.addEventListener('keyup', (e)=>{
  if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','w','a','s','d'].includes(e.key)){
    player.dirX = 0; player.dirY = 0;
  }
});

/* ---------- Joystick (Pointer Events) - corrigido ---------- */
const joystick = document.getElementById('joystick');
const stick = document.getElementById('stick');
let dragging = false;
let activePointerId = null;
let joystickRect = null, stickRect = null, joystickCenter = {x:0,y:0}, maxRadius = 1;

function updateRects(){
  joystickRect = joystick.getBoundingClientRect();
  stickRect = stick.getBoundingClientRect();
  joystickCenter = { x: joystickRect.left + joystickRect.width/2, y: joystickRect.top + joystickRect.height/2 };
  maxRadius = (joystickRect.width - stickRect.width) / 2;
}
window.addEventListener('resize', updateRects);
updateRects();

function startDrag(e){
  e.preventDefault();
  joystick.setPointerCapture(e.pointerId);
  activePointerId = e.pointerId;
  dragging = true;
  updateRects();
  moveStickTo(e.clientX, e.clientY);
}
function moveStickTo(clientX, clientY){
  const dx = clientX - joystickCenter.x;
  const dy = clientY - joystickCenter.y;
  const dist = Math.hypot(dx, dy);
  const limited = dist > maxRadius ? maxRadius / dist : 1;
  const sx = dx * limited;
  const sy = dy * limited;
  stick.style.transform = `translate(${sx}px, ${sy}px)`;
  // normalized direction - threshold to avoid jitter
  const nx = sx / (maxRadius || 1);
  const ny = sy / (maxRadius || 1);
  const thr = 0.25;
  player.dirX = Math.abs(nx) > thr ? (nx > 0 ? 1 : -1) : 0;
  player.dirY = Math.abs(ny) > thr ? (ny > 0 ? 1 : -1) : 0;
}
function endDrag(){
  dragging = false;
  activePointerId = null;
  stick.style.transform = 'translate(0, 0)';
  player.dirX = 0; player.dirY = 0;
}

joystick.addEventListener('pointerdown', startDrag);
joystick.addEventListener('pointermove', (e)=>{
  if(!dragging || e.pointerId !== activePointerId) return;
  e.preventDefault();
  moveStickTo(e.clientX, e.clientY);
});
joystick.addEventListener('pointerup', (e)=>{
  if(e.pointerId !== activePointerId) return;
  joystick.releasePointerCapture(e.pointerId);
  endDrag();
});
joystick.addEventListener('pointercancel', (e)=>{
  if(e.pointerId !== activePointerId) return;
  endDrag();
});

/* ---------- Start / Pause / Reset ---------- */
startBtn.addEventListener('click', ()=>{
  resetGame();
  running = true; paused = false;
  startTime = performance.now();
  startBtn.textContent = 'Reiniciar';
});
function togglePause(){ if(!running) return; paused = !paused; pauseBtn.textContent = paused ? 'Retomar' : 'Pausar'; }
pauseBtn.addEventListener('click', togglePause);

function resetGame(){
  map = genMap();
  score = 0; lives = 3; elapsed = 0;
  scoreEl.textContent = score; livesEl.textContent = lives; timerEl.textContent = '00:00';
  player.x = 1.5; player.y = 1.5; player.dirX = 0; player.dirY = 0; player.mouthAnim = 0;
  ghosts[0].x = tileCount-2.5; ghosts[0].y = 1.5; ghosts[1].x = 1.5; ghosts[1].y = tileCount-2.5; ghosts[2].x = tileCount-2.5; ghosts[2].y = tileCount-2.5;
}

/* ---------- Helpers ---------- */
function formatTime(sec){
  const m = Math.floor(sec/60).toString().padStart(2,'0');
  const s = (sec%60).toString().padStart(2,'0');
  return `${m}:${s}`;
}

/* init */
resetGame();
</script>
</body>
</html>

  
