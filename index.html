<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Pac-Man</title>
  <style>
    body {
      margin: 0;
      background: black;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      height: 100vh;
      overflow: hidden;
      color: white;
      font-family: Arial, sans-serif;
    }

    #game {
      position: relative;
      width: 504px;
      height: 504px;
      background: #222;
      display: grid;
      grid-template-columns: repeat(24, 20px);
      grid-template-rows: repeat(24, 20px);
      gap: 2px;
      margin-bottom: 20px;
    }

    .cell {
      width: 20px;
      height: 20px;
      background: #111;
      border-radius: 3px;
      position: relative;
    }

    .wall { background: #0033ff; }

    .pacman {
      border-radius: 50%;
      z-index: 10;
      transition: background 0.2s ease;
    }
    .pacman.powered { background: orange !important; }

    .dot {
      position: absolute;
      top: 7px;
      left: 7px;
      width: 6px;
      height: 6px;
      background: white;
      border-radius: 50%;
    }

    .fruit {
      position: absolute;
      top: 5px;
      left: 5px;
      width: 10px;
      height: 10px;
      background: orange;
      border-radius: 50%;
      z-index: 8;
      box-shadow: 0 0 5px #ff6600;
    }

    .ghost {
      width: 20px;
      height: 20px;
      position: relative;
      z-index: 9;
      border-radius: 4px;
    }

    .ghost.red    { background: red; }
    .ghost.pink   { background: pink; }
    .ghost.cyan   { background: cyan; }
    .ghost.orange { background: orange; }

    .ghost.vulnerable { background: lightblue !important; }

    #status {
      font-size: 1.2rem;
      height: 1.5em;
      margin-bottom: 5px;
    }

    #score {
      font-size: 1.1rem;
      margin-bottom: 10px;
    }

    #colorMenu {
      margin-bottom: 10px;
      font-size: 1rem;
      color: white;
    }

    #colorSelect {
      margin-left: 10px;
      padding: 5px;
      font-size: 1rem;
      border-radius: 4px;
      background: #222;
      color: white;
      border: 1px solid #555;
    }

    button {
      background: #444;
      border: none;
      color: white;
      font-size: 1rem;
      padding: 10px 20px;
      margin: 0 10px;
      border-radius: 5px;
      cursor: pointer;
      transition: background 0.2s ease;
    }

    button:hover { background: #666; }

    #buttons {
      display: flex;
      justify-content: center;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }

    #touch-controls {
      display: none;
      flex-direction: column;
      align-items: center;
      margin-top: 10px;
    }

    #touch-controls .row {
      display: flex;
      justify-content: center;
    }

    .dir-btn {
      background: #333;
      color: white;
      font-size: 1.5rem;
      padding: 15px 20px;
      margin: 5px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
    }

    .dir-btn:active {
      background: #666;
    }

    @media (max-width: 768px) {
      #touch-controls {
        display: flex;
      }
    }
  </style>
</head>
<body>

<div id="game"></div>
<div id="score">Pontuação: 0</div>
<div id="status"></div>

<div id="colorMenu">
  <label for="colorSelect">Cor do Pac-Man:</label>
  <select id="colorSelect">
    <option value="yellow" selected>Amarelo</option>
    <option value="green">Verde</option>
    <option value="blue">Azul</option>
    <option value="red">Vermelho</option>
    <option value="pink">Rosa</option>
  </select>
</div>

<div id="buttons">
  <button id="startBtn">Jogar</button>
  <button id="speedBtn" style="display:none;">Acelerar Fantasmas</button>
  <button id="restartBtn" style="display:none;">Reiniciar</button>
</div>

<div id="touch-controls">
  <div class="row">
    <button class="dir-btn" data-dir="up">⬆️</button>
  </div>
  <div class="row">
    <button class="dir-btn" data-dir="left">⬅️</button>
    <button class="dir-btn" data-dir="down">⬇️</button>
    <button class="dir-btn" data-dir="right">➡️</button>
  </div>
</div>

<script>
const width = 24;
// 0 = vazio, 1 = parede, 2 = bolinha, 3 = fruta (power-up)
let layout = [], cells = [], pacmanPosition, ghosts = [];
let gameOver = false, ghostInterval, score = 0, ghostSpeed = 500;
let poweredUp = false, powerTimeout;
let pacmanColor = 'yellow';

const game = document.getElementById('game');
const status = document.getElementById('status');
const scoreDisplay = document.getElementById('score');
const startBtn = document.getElementById('startBtn');
const restartBtn = document.getElementById('restartBtn');
const speedBtn = document.getElementById('speedBtn');
const colorSelect = document.getElementById('colorSelect');

colorSelect.addEventListener('change', () => {
  pacmanColor = colorSelect.value;
  drawPacman();
});

const index = (r, c) => r * width + c;
const inBounds = (r, c) => r >= 0 && r < width && c >= 0 && c < width;

function shuffle(arr){
  for(let i=arr.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

// --- GERAÇÃO DE LABIRINTO ESTILO PAC-MAN ---
// Usa DFS em células ímpares para criar corredores e deixa a borda fechada.
// Adiciona uma “casa” de fantasmas no centro e túnel lateral de teleporte.
function createMazeLayout() {
  // começa tudo como parede
  layout = Array(width*width).fill(1);

  // marca as células ímpares como "potenciais caminhos" e roda DFS
  const carve = (r, c) => {
    layout[index(r, c)] = 2; // caminho com bolinhas
    const dirs = shuffle([[0,2],[0,-2],[2,0],[-2,0]]);
    for(const [dr,dc] of dirs){
      const nr = r + dr, nc = c + dc;
      const wr = r + dr/2, wc = c + dc/2; // parede entre
      if(inBounds(nr,nc) && nr>0 && nr<width-1 && nc>0 && nc<width-1 && layout[index(nr,nc)] === 1){
        layout[index(wr,wc)] = 2; // abre a parede entre
        carve(nr,nc);
      }
    }
  };

  // ponto inicial (ímpar,ímpar)
  carve(1,1);

  // túnel horizontal (linha do meio)
  const mid = Math.floor(width/2);
  layout[index(mid,0)] = 2;
  layout[index(mid,1)] = 2;
  layout[index(mid,width-1)] = 2;
  layout[index(mid,width-2)] = 2;

  // "casa" dos fantasmas (4x3) no centro com uma abertura
  const ghTop = mid-2, ghLeft = mid-3;
  for(let r=ghTop; r<ghTop+4; r++){
    for(let c=ghLeft; c<ghLeft+6; c++){
      // contorno como parede, dentro vazio
      if(r===ghTop || r===ghTop+3 || c===ghLeft || c===ghLeft+5){
        layout[index(r,c)] = 1;
      } else {
        layout[index(r,c)] = 0; // sem bolinhas dentro da casa
      }
    }
  }
  // porta da casa (abertura)
  layout[index(ghTop+3, mid)] = 2;

  // limpa o centro (uma cruz) para ficar mais “clássico”
  for(let c=2; c<width-2; c++) layout[index(mid, c)] = (layout[index(mid,c)]===1?1:2);
  for(let r=2; r<width-2; r++) layout[index(r, mid)] = (layout[index(r,mid)]===1?1:2);

  // garante bordas externas fechadas
  for(let i=0;i<width;i++){
    layout[index(0,i)] = 1;
    layout[index(width-1,i)] = 1;
    layout[index(i,0)] = (i===mid?2:1);               // túnel
    layout[index(i,width-1)] = (i===mid?2:1);         // túnel
  }

  // posição inicial do Pac-Man (perto do meio-esquerda)
  layout[index(mid+5, 2)] = 0; // vazio sem bolinha
  pacmanPosition = index(mid+5, 2);

  // coloca frutas/power-ups nos quatro “quase cantos”
  const fruits = [
    index(1,1), index(1,width-2),
    index(width-2,1), index(width-2,width-2)
  ];
  fruits.forEach(pos => { if(layout[pos] !== 1){ layout[pos] = 3; } });

  // garante que existam bolinhas suficientes (qualquer caminho 2 é bolinha)
}

function createGrid(){
  game.innerHTML=''; cells=[];
  layout.forEach(value=>{
    const cell = document.createElement('div'); cell.classList.add('cell');
    if(value===1) cell.classList.add('wall');
    if(value===2){ const dot=document.createElement('div'); dot.classList.add('dot'); cell.appendChild(dot); }
    if(value===3){ const fruit=document.createElement('div'); fruit.classList.add('fruit'); cell.appendChild(fruit); }
    game.appendChild(cell); cells.push(cell);
  });
}

function drawPacman(){
  const cell = cells[pacmanPosition];
  cell.classList.add('pacman');
  cell.style.backgroundColor = poweredUp ? 'orange' : pacmanColor;
}

function removePacman(){
  const cell = cells[pacmanPosition];
  cell.classList.remove('pacman','powered');
  cell.style.backgroundColor = '';
}

class Ghost {
  constructor(startPos, colorClass){
    this.startPos=startPos; this.position=startPos;
    this.vulnerable=false; this.isDead=false;
    this.element=document.createElement('div'); 
    this.element.classList.add('ghost',colorClass);
    cells[this.position].appendChild(this.element);
  }
  move(){
    if(this.isDead) return;
    const directions=[-1,1,-width,width];

    const wrapMove = (pos, d) => {
      let r = Math.floor(pos/width), c = pos%width;
      if(d === -1){ // esquerda
        c = (c===0)? width-1 : c-1;
      } else if(d === 1){ // direita
        c = (c===width-1)? 0 : c+1;
      } else if(d === -width){ // cima
        r = r-1;
      } else if(d === width){ // baixo
        r = r+1;
      }
      if(!inBounds(r,c)) return -1;
      return index(r,c);
    };

    function manhattanDist(a,b){
      const x1=a%width,y1=Math.floor(a/width),x2=b%width,y2=Math.floor(b/width);
      return Math.abs(x1-x2)+Math.abs(y1-y2);
    }

    let validMoves=directions.map(d=>{
      const newPos = wrapMove(this.position,d);
      return {d,newPos};
    }).filter(m=> m.newPos>=0 && layout[m.newPos]!==1);

    if(validMoves.length===0) return;

    validMoves.sort((ma,mb)=>{
      const distA=manhattanDist(ma.newPos,pacmanPosition);
      const distB=manhattanDist(mb.newPos,pacmanPosition);
      return this.vulnerable?distB-distA:distA-distB;
    });

    const best = validMoves[0];
    cells[this.position].removeChild(this.element);
    this.position = best.newPos;
    cells[this.position].appendChild(this.element);
  }
  makeVulnerable(){ this.vulnerable=true; this.element.classList.add('vulnerable'); }
  makeNormal(){ this.vulnerable=false; this.element.classList.remove('vulnerable'); }
  kill(){
    this.isDead=true; this.makeNormal();
    if(this.element.parentNode) this.element.parentNode.removeChild(this.element);
    setTimeout(()=>{ this.isDead=false; this.position=this.startPos; cells[this.position].appendChild(this.element); },5000);
  }
  remove(){ if(this.element.parentNode) this.element.parentNode.removeChild(this.element); }
}

function startGhosts(){
  stopGhosts();
  ghostInterval=setInterval(()=>{
    if(gameOver) return;
    ghosts.forEach(ghost=>{
      if(ghost.isDead) return;
      ghost.move();
      if(ghost.position===pacmanPosition){
        if(poweredUp && ghost.vulnerable){ updateScore(100); ghost.kill(); }
        else if(!poweredUp){ endGame('Você foi pego pelos fantasmas!'); }
      }
    });
  },ghostSpeed);
}

function stopGhosts(){ clearInterval(ghostInterval); }

function updateScore(points){ score+=points; scoreDisplay.textContent='Pontuação: '+score; }

function endGame(msg){
  gameOver=true; stopGhosts(); status.textContent=msg;
  restartBtn.style.display='inline-block'; speedBtn.style.display='none'; startBtn.style.display='none';
}

function resetGame(){
  gameOver=false; score=0; scoreDisplay.textContent='Pontuação: 0'; status.textContent='';
  poweredUp=false; clearTimeout(powerTimeout);

  createMazeLayout(); // << novo labirinto gerado
  createGrid();

  // posições dos fantasmas (dentro/na porta da casa)
  ghosts.forEach(g=>g.remove()); ghosts=[];
  const mid = Math.floor(width/2);
  const ghTop = mid-2, ghLeft = mid-3;
  const ghostStarts = [
    index(ghTop+1, mid),       // centro
    index(ghTop+1, mid-1),
    index(ghTop+1, mid+1),
    index(ghTop+2, mid)
  ];
  ghosts.push(new Ghost(ghostStarts[0],'red'));
  ghosts.push(new Ghost(ghostStarts[1],'pink'));
  ghosts.push(new Ghost(ghostStarts[2],'cyan'));
  ghosts.push(new Ghost(ghostStarts[3],'orange'));

  drawPacman();
  restartBtn.style.display='none'; speedBtn.style.display='inline-block'; startBtn.style.display='none';
  startGhosts();
}

function remainingPellets(){
  return layout.some(v=> v===2 || v===3);
}

function movePacman(dir){
  if(gameOver) return;

  const wrapMove = (pos, d) => {
    let r = Math.floor(pos/width), c = pos%width;
    if(d === -1){ // esquerda
      c = (c===0)? width-1 : c-1;
    } else if(d === 1){ // direita
      c = (c===width-1)? 0 : c+1;
    } else if(d === -width){ // cima
      r = r-1;
    } else if(d === width){ // baixo
      r = r+1;
    }
    if(!inBounds(r,c)) return -1;
    return index(r,c);
  };

  const newPos = wrapMove(pacmanPosition, dir);
  if(newPos<0 || layout[newPos]===1) return;

  removePacman();
  pacmanPosition = newPos;

  if(layout[pacmanPosition]===2){
    layout[pacmanPosition]=0;
    const dot=cells[pacmanPosition].querySelector('.dot'); if(dot) dot.remove();
    updateScore(10);
  }
  if(layout[pacmanPosition]===3){
    layout[pacmanPosition]=0;
    const fruit=cells[pacmanPosition].querySelector('.fruit'); if(fruit) fruit.remove();
    updateScore(50);
    activatePowerUp();
  }

  drawPacman();

  ghosts.forEach(ghost=>{
    if(ghost.position===pacmanPosition){
      if(poweredUp && ghost.vulnerable){ updateScore(100); ghost.kill(); }
      else if(!poweredUp){ endGame('Você foi pego pelos fantasmas!'); }
    }
  });

  if(!remainingPellets()){ endGame('Você ganhou! Parabéns!'); }
}

function activatePowerUp(){
  poweredUp=true; drawPacman(); ghosts.forEach(g=>{ if(!g.isDead) g.makeVulnerable(); });
  if(powerTimeout) clearTimeout(powerTimeout);
  powerTimeout=setTimeout(()=>{ poweredUp=false; drawPacman(); ghosts.forEach(g=>g.makeNormal()); },8000);
}

// --- Teclado ---
document.addEventListener('keydown',e=>{
  if(gameOver) return;
  switch(e.key){
    case 'ArrowUp': case 'w': case 'W': movePacman(-width); break;
    case 'ArrowDown': case 's': case 'S': movePacman(width); break;
    case 'ArrowLeft': case 'a': case 'A': movePacman(-1); break;
    case 'ArrowRight': case 'd': case 'D': movePacman(1); break;
  }
});

// --- Botões virtuais ---
document.querySelectorAll('.dir-btn').forEach(btn => {
  btn.addEventListener('touchstart', () => {
    const dir = btn.dataset.dir;
    if(dir === 'up') movePacman(-width);
    if(dir === 'down') movePacman(width);
    if(dir === 'left') movePacman(-1);
    if(dir === 'right') movePacman(1);
  });
});

// --- Swipe ---
let touchStartX = 0, touchStartY = 0;
let touchEndX = 0, touchEndY = 0;

function handleSwipe() {
  const dx = touchEndX - touchStartX;
  const dy = touchEndY - touchStartY;

  if (Math.abs(dx) > Math.abs(dy)) {
    if (dx > 30) movePacman(1);
    else if (dx < -30) movePacman(-1);
  } else {
    if (dy > 30) movePacman(width);
    else if (dy < -30) movePacman(-width);
  }
}

document.addEventListener("touchstart", e => {
  touchStartX = e.changedTouches[0].screenX;
  touchStartY = e.changedTouches[0].screenY;
}, false);

document.addEventListener("touchend", e => {
  touchEndX = e.changedTouches[0].screenX;
  touchEndY = e.changedTouches[0].screenY;
  handleSwipe();
}, false);

startBtn.addEventListener('click', resetGame);
restartBtn.addEventListener('click', resetGame);
speedBtn.addEventListener('click', ()=>{
  ghostSpeed=ghostSpeed===500?250:500;
  speedBtn.textContent=ghostSpeed===500?'Acelerar Fantasmas':'Normalizar Velocidade';
  startGhosts();
});

// inicia com o botão "Jogar"
</script>

</body>
</html>
  